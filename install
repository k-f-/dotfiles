#!/usr/bin/env bash
#
# Dotfiles Installation Script
# A modern, maintainable installer for dotfiles using GNU Stow
#
# Usage: ./install [OPTIONS]
#   --help          Show this help message
#   --dry-run       Show what would be done without making changes
#   --no-packages   Skip package installation
#   --minimal       Install only core packages
#   --verbose       Show detailed output
#   --force         Skip backups and overwrite existing files

set -euo pipefail

# Force bash shell to avoid zsh subshell hangs (brew/et)
[[ "${SHELL:-}" == */zsh ]] && export SHELL=/bin/bash

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -L)"
STOW_TARGET="${HOME}"
BACKUP_DIR="${HOME}/.dotfiles-backup-$(date +%Y%m%d-%H%M%S)"

source "${DOTFILES_DIR}/scripts/lib/output.sh"

# Core packages that should be installed on all systems (alphabetically sorted)
CORE_PACKAGES=(
    bash
    git
    vim
    zsh
)

# Optional packages - can be skipped with --minimal (alphabetically sorted)
OPTIONAL_PACKAGES=(
    aerospace
    aws
    claude-code
    doom
    emacs
    gh
    gnupg
    homebrew
    kitty
    mackup
    mail
    opencode
    secrets
    sketchybar
    skhd
    ssh
    tmux
    universal-wm
    yabai
    yt-dlp
)

# Flags
DRY_RUN=false
INSTALL_PACKAGES=true
MINIMAL=false
VERBOSE=false
FORCE=false
UNATTENDED=false
RELINK=false  # Automatically relink symlinks from old dotfiles locations
FULL_INSTALL=false  # Install desktop packages in addition to core packages

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

write_dotfiles_env() {
    local env_dir="${HOME}/.config/dotfiles"
    local env_file="${env_dir}/env"
    if [[ "${DRY_RUN}" == "true" ]]; then
        out_verbose "Would write DOTFILES_DIR to ${env_file}"
        return 0
    fi
    mkdir -p "${env_dir}"
    cat > "${env_file}" << EOF
# Dotfiles environment — written by install script
# Source this in shell configs for location-independent DOTFILES_DIR
export DOTFILES_DIR="${DOTFILES_DIR}"
EOF
    out_success "Wrote DOTFILES_DIR to ${env_file}"
}

summarize_theme_install() {
    local output="$1"
    local theme=""
    local apps=()

    theme=$(printf "%s\n" "${output}" | sed -n 's/.*Theme: \([^ (][^ (]*\).*/\1/p' | head -1)
    if [[ -z "${theme}" ]]; then
        theme=$(printf "%s\n" "${output}" | sed -n 's/.*Selected theme: \([^ ]*\).*/\1/p' | head -1)
    fi

    if printf "%s\n" "${output}" | grep -q "Kitty theme linked"; then
        apps+=("kitty")
    fi
    if printf "%s\n" "${output}" | grep -q "VS Code theme set"; then
        apps+=("vscode")
    fi
    if printf "%s\n" "${output}" | grep -q "Zsh theme installed"; then
        apps+=("zsh")
    fi
    if printf "%s\n" "${output}" | grep -q "Terminal.app theme imported"; then
        apps+=("terminal")
    fi

    local app_list=""
    for app in "${apps[@]}"; do
        if [[ -z "${app_list}" ]]; then
            app_list="${app}"
        else
            app_list="${app_list}, ${app}"
        fi
    done

    if [[ -z "${app_list}" ]]; then
        app_list="no apps"
    fi

    if [[ -n "${theme}" ]]; then
        echo "${theme} → ${app_list}"
    else
        echo "${app_list}"
    fi
}

show_help() {
    cat << EOF
Dotfiles Installation Script

Usage: ./install [OPTIONS]

OPTIONS:
    --help          Show this help message
    --dry-run       Show what would be done without making changes
    --no-packages   Skip package manager installations
    --minimal       Install only core packages (bash, git, vim, zsh)
    --full          Install desktop packages in addition to core packages (Slack, Aerospace, Kitty, etc.)
    --verbose       Show detailed output
    --force         Skip backups and overwrite existing files (use with caution!)
    --unattended    Non-interactive deploy (implies --force --relink, uses defaults)
    --relink        Automatically relink symlinks from old dotfiles locations

HANDLING EXISTING FILES:
    By default, existing files are backed up to ~/.dotfiles-backup-TIMESTAMP/
    Existing symlinks to these dotfiles are detected and left alone.
    Broken symlinks are automatically removed.

    If you have symlinks from a previous dotfiles location (e.g., Dropbox/Code/dotfiles),
    use --relink to automatically update them to the new location.

    Use --dry-run to see what will happen before making changes.

EXAMPLES:
    ./install                    # Install core packages and dotfiles (default)
    ./install --full             # Install core + desktop packages (Slack, Aerospace, Kitty, etc.)
    ./install --minimal          # Install core configs only
    ./install --dry-run          # Preview changes without applying
    ./install --full --dry-run   # Preview full installation
    ./install --relink           # Update symlinks from old dotfiles location
    ./install --relink --dry-run # Preview relinking without changes
    ./install --force            # Overwrite existing files without backup
    ./install --unattended       # Run non-interactively using preferences defaults

EOF
    exit 0
}

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if [[ -f /etc/debian_version ]]; then
            echo "debian"
        elif [[ -f /etc/redhat-release ]]; then
            echo "redhat"
        else
            echo "linux"
        fi
    else
        echo "unknown"
    fi
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Install package manager packages
install_packages() {
    local os="$1"

    if [[ "${INSTALL_PACKAGES}" != "true" ]]; then
        out_warning "Skipping package installation (--no-packages)"
        return 0
    fi

    section "Packages"

    case "${os}" in
        macos)
            if ! command_exists brew; then
                fail "Homebrew not found. Install from https://brew.sh"
                return 1
            fi

            # Install core packages (always)
            if [[ -f "${DOTFILES_DIR}/homebrew/Brewfile.core" ]]; then
                local core_output=""
                if [[ "${DRY_RUN}" == "false" ]]; then
                    if run_with_status "Installing core packages" \
                        brew bundle --file="${DOTFILES_DIR}/homebrew/Brewfile.core"; then
                        core_output="${RWS_OUTPUT}"
                    else
                        core_output="${RWS_OUTPUT}"
                        fail "core packages"
                    fi
                    out_verbose "${core_output}"
                fi
                if [[ "${FULL_INSTALL}" != "true" ]]; then
                    out_info "Run with --full to also install desktop apps (Slack, Aerospace, Kitty, etc.)"
                fi
            else
                fail "Brewfile.core not found"
            fi
            
            # Install desktop packages (only with --full)
            if [[ "${FULL_INSTALL}" == "true" ]] && [[ -f "${DOTFILES_DIR}/homebrew/Brewfile.desktop" ]]; then
                local desktop_output=""
                if [[ "${DRY_RUN}" == "false" ]]; then
                    if run_with_status "Installing desktop packages" \
                        brew bundle --file="${DOTFILES_DIR}/homebrew/Brewfile.desktop"; then
                        desktop_output="${RWS_OUTPUT}"
                    else
                        desktop_output="${RWS_OUTPUT}"
                        fail "desktop packages"
                    fi
                    out_verbose "${desktop_output}"
                fi
            fi
            ;;

        debian)
            if [[ -f "${DOTFILES_DIR}/scripts/install-debian-packages.sh" ]]; then
                out_verbose "Running: ${DOTFILES_DIR}/scripts/install-debian-packages.sh"
                if [[ "${DRY_RUN}" == "false" ]]; then
                    if ! bash "${DOTFILES_DIR}/scripts/install-debian-packages.sh"; then
                        fail "debian packages"
                    fi
                fi
            else
                fail "Debian package script not found"
            fi
            ;;

        *)
            out_warning "Unknown OS, skipping package installation"
            ;;
    esac

    local package_count=0
    if [[ "${DRY_RUN}" == "false" ]]; then
        if [[ -n "${core_output:-}" ]]; then
            package_count=$((package_count + $(printf "%s" "${core_output}" | wc -l | tr -d ' ')))
        fi
        if [[ -n "${desktop_output:-}" ]]; then
            package_count=$((package_count + $(printf "%s" "${desktop_output}" | wc -l | tr -d ' ')))
        fi
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        section_end "skipped (dry run)"
    else
        section_end "${package_count} installed"
    fi
}

# Check if a symlink points to a dotfiles directory (any location)
is_dotfiles_symlink() {
    local target="$1"
    # Common patterns for dotfiles directories
    [[ "$target" == *"/dotfiles/"* ]] || \
    [[ "$target" == *"/.dotfiles/"* ]] || \
    [[ "$target" == *"/.dots/"* ]] || \
    [[ "$target" == *"/Dropbox/Code/dotfiles/"* ]] || \
    [[ "$target" == *"/iCloud/"*"/dotfiles/"* ]]
}

# Remove conflicting targets for a stow package (used in --force mode)
# This handles the case where existing symlinks point to the same dotfiles
# through a different path (e.g., iCloud logical vs physical path)
remove_stow_conflicts() {
    local package="$1"
    local package_dir="${DOTFILES_DIR}/${package}"

    [[ ! -d "${package_dir}" ]] && return 0

    while IFS= read -r -d '' file; do
        local rel_path="${file#$package_dir/}"
        # Handle stow's --dotfiles convention: dot-foo -> .foo
        local stowed_path="${rel_path//dot-/.}"
        local target_file="${STOW_TARGET}/${stowed_path}"

        if [[ -L "${target_file}" ]]; then
            local link_target
            link_target=$(readlink "${target_file}")
            # Remove if it points to any dotfiles directory (same repo, different path)
            if [[ "$link_target" == *"/dotfiles/"* ]] || [[ "$link_target" == *"dotfiles/"* ]]; then
                out_verbose "Removing conflicting symlink: ${target_file} -> ${link_target}"
                rm -f "${target_file}"
            else
                out_verbose "Removing non-dotfiles target: ${target_file}"
                rm -f "${target_file}"
            fi
        elif [[ -e "${target_file}" ]]; then
            # Regular file — back it up before removing
            local backup_path="${BACKUP_DIR}/${stowed_path}"
            mkdir -p "$(dirname "${backup_path}")"
            out_verbose "Backing up and removing: ${target_file}"
            mv "${target_file}" "${backup_path}"
        fi
    done < <(find "${package_dir}" \( -type f -o -type l \) -print0)

    # Also remove conflicting directory symlinks (tree-folded stow dirs)
    while IFS= read -r -d '' dir; do
        local rel_path="${dir#$package_dir/}"
        local stowed_path="${rel_path//dot-/.}"
        local target_dir="${STOW_TARGET}/${stowed_path}"

        if [[ -L "${target_dir}" ]]; then
            local link_target
            link_target=$(readlink "${target_dir}")
            if [[ "$link_target" == *"/dotfiles/"* ]] || [[ "$link_target" == *"dotfiles/"* ]]; then
                out_verbose "Removing conflicting dir symlink: ${target_dir} -> ${link_target}"
                rm -f "${target_dir}"
            fi
        fi
    done < <(find "${package_dir}" -mindepth 1 -type d -print0)
}

# Backup existing files that would conflict with stow
backup_conflicts() {
    local package="$1"
    local package_dir="${DOTFILES_DIR}/${package}"

    if [[ ! -d "${package_dir}" ]]; then
        return 0
    fi

    # Find files that would be created by stow
    while IFS= read -r -d '' file; do
        local rel_path="${file#$package_dir/}"
        # Handle stow's --dotfiles convention: dot-foo -> .foo
        local stowed_path="${rel_path//dot-/.}"
        local target_file="${STOW_TARGET}/${stowed_path}"

        # Skip if target doesn't exist
        [[ ! -e "${target_file}" ]] && [[ ! -L "${target_file}" ]] && continue

        # Skip if target is inside a tree-folded stow directory
        # (a parent dir is a symlink pointing into our dotfiles repo).
        # Without this check, backup_conflicts will mv files OUT of the repo
        # when stow has tree-folded a directory (e.g. ~/.bashrc.d -> dotfiles/bash/dot-bashrc.d)
        local _check_path="${target_file}"
        local _is_tree_folded=false
        while [[ "${_check_path}" != "${STOW_TARGET}" && "${_check_path}" != "/" ]]; do
            _check_path="$(dirname "${_check_path}")"
            if [[ -L "${_check_path}" ]]; then
                local _resolved
                _resolved="$(readlink -f "${_check_path}" 2>/dev/null)" || true
                if [[ "${_resolved}" == "${DOTFILES_DIR}"* ]]; then
                    _is_tree_folded=true
                    break
                fi
            fi
        done
        if [[ "${_is_tree_folded}" == "true" ]]; then
            out_verbose "Skipping tree-folded stow path: ${target_file}"
            continue
        fi

        # If target is a symlink
        if [[ -L "${target_file}" ]]; then
            local link_target=$(readlink "${target_file}")

            # Check if it points to our current dotfiles directory
            # Resolve relative symlinks to check if they point to current dotfiles
            local resolved_target
            if [[ "${link_target}" = /* ]]; then
                # Absolute path
                resolved_target="${link_target}"
            else
                # Relative path - resolve from $HOME
                resolved_target="$(cd "$(dirname "${target_file}")" && cd "$(dirname "${link_target}")" 2>/dev/null && pwd)/$(basename "${link_target}")" || resolved_target=""
            fi

            if [[ "${link_target}" == *"${DOTFILES_DIR}"* ]] || [[ "${resolved_target}" == "${DOTFILES_DIR}"* ]]; then
                out_verbose "Symlink already managed: ${target_file}"
                continue
            fi

            # Check if it's a broken/stale symlink
            if [[ ! -e "${target_file}" ]]; then
                out_warning "Removing broken symlink: ${target_file} -> ${link_target}"
                if [[ "${DRY_RUN}" == "false" ]]; then
                    rm "${target_file}"
                fi
                continue
            fi

            # Check if it points to another dotfiles directory (NOT the current one)
            if is_dotfiles_symlink "${link_target}" && \
               [[ "${link_target}" != *"${DOTFILES_DIR}"* ]] && \
               [[ "${resolved_target}" != "${DOTFILES_DIR}"* ]]; then
                # Only relink if it's pointing to a DIFFERENT dotfiles directory
                if [[ "${RELINK}" == "true" ]]; then
                    out_verbose "Relinking from old dotfiles: ${target_file}"
                    out_verbose "  Old: ${link_target}"
                    out_verbose "  New: ${DOTFILES_DIR}/${package}/${rel_path}"
                    if [[ "${DRY_RUN}" == "false" ]]; then
                        rm "${target_file}"
                    fi
                else
                    out_warning "Dotfiles symlink from different location: ${target_file}"
                    out_warning "  Points to: ${link_target}"
                    out_warning "  Use --relink to automatically update these symlinks"
                fi
                continue
            fi

            # Symlink to somewhere else (not dotfiles)
            out_warning "External symlink found: ${target_file} -> ${link_target}"
            if [[ "${DRY_RUN}" == "false" ]] && [[ "${FORCE}" == "true" ]]; then
                mkdir -p "$(dirname "${BACKUP_DIR}/${stowed_path}")"
                mv "${target_file}" "${BACKUP_DIR}/${stowed_path}"
                echo "${link_target}" > "${BACKUP_DIR}/${stowed_path}.symlink-target"
            fi
        # Regular file exists
        elif [[ -e "${target_file}" ]]; then
            out_verbose "Backing up: ${target_file}"
            if [[ "${DRY_RUN}" == "false" ]]; then
                mkdir -p "$(dirname "${BACKUP_DIR}/${stowed_path}")"
                mv "${target_file}" "${BACKUP_DIR}/${stowed_path}"
            fi
        fi
    done < <(find "${package_dir}" \( -type f -o -type l \) -print0)
}

# Bootstrap oh-my-zsh if not already installed
bootstrap_oh_my_zsh() {
    section "oh-my-zsh"

    if [[ -f "$HOME/.oh-my-zsh/oh-my-zsh.sh" ]]; then
        out_verbose "oh-my-zsh already installed"
        section_end "skipped"
        return 0
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        out_verbose "Would install oh-my-zsh"
        section_end "skipped (dry run)"
        return 0
    fi

    # Remove stale/empty directory (e.g. from iCloud sync) so installer doesn't bail
    if [[ -d "$HOME/.oh-my-zsh" ]] && [[ ! -f "$HOME/.oh-my-zsh/oh-my-zsh.sh" ]]; then
        out_verbose "Removing stale ~/.oh-my-zsh directory"
        rm -rf "$HOME/.oh-my-zsh"
    fi

    if ! curl -fsSL --connect-timeout 5 https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh > /dev/null 2>&1; then
        fail "Cannot reach oh-my-zsh installer (offline?). Skipping."
        section_end "skipped"
        return 0
    fi

    if ZSH= sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended; then
        section_end "installed"
    else
        fail "install failed"
        section_end "failed"
    fi
}

# Initialize git submodules
init_submodules() {
    section "Submodules"

    if [[ ! -f "${DOTFILES_DIR}/.gitmodules" ]]; then
        out_verbose "No submodules found"
        section_end "0 public, 0 private"
        return 0
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        out_verbose "Would initialize submodules"
        section_end "skipped (dry run)"
        return 0
    fi

    # Public submodules (HTTPS - always work)
    local public_submodules=("aerospace-layout-manager" "agentic-dev-standards" "kitty/dot-config/kitty/kitty_search")
    local private_submodules=("aesthetics" "agr-cli")
    local public_count=0
    local private_count=0

    if run_with_status "Initializing public submodules" \
        git -C "${DOTFILES_DIR}" submodule update --init "${public_submodules[@]}"; then
        public_count=${#public_submodules[@]}
        tick
    else
        fail "public submodules"
    fi

    if ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=5 -o BatchMode=yes -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
        if run_with_status "Initializing private submodules (SSH)" \
            git -C "${DOTFILES_DIR}" submodule update --init "${private_submodules[@]}"; then
            private_count=${#private_submodules[@]}
            tick
        else
            fail "private submodules (SSH)"
        fi
    elif command -v gh >/dev/null 2>&1 && gh auth status 2>&1 | grep -q "Logged in"; then
        git -C "${DOTFILES_DIR}" config submodule.aesthetics.url "https://github.com/k-f-/aesthetics.git" || true
        git -C "${DOTFILES_DIR}" config submodule.agr-cli.url "https://github.com/k-f-/agr-cli.git" || true

        local gh_path
        gh_path="$(command -v gh)"

        if run_with_status "Initializing private submodules (gh CLI)" \
            git -C "${DOTFILES_DIR}" \
                -c "credential.https://github.com.helper=" \
                -c "credential.https://github.com.helper=!${gh_path} auth git-credential" \
                submodule update --init "${private_submodules[@]}"; then
            private_count=${#private_submodules[@]}
            tick
        else
            fail "private submodules (GitHub CLI)"
        fi

        git -C "${DOTFILES_DIR}" config submodule.aesthetics.url "git@github.com:k-f-/aesthetics.git" || true
        git -C "${DOTFILES_DIR}" config submodule.agr-cli.url "git@github.com:k-f-/agr-cli.git" || true
    else
        # No auth available - print instructions
        out_warning "Private submodules require authentication"
        out_detail "The following submodules could not be initialized:"
        out_detail "- aesthetics (terminal themes)"
        out_detail "- agr-cli (session archive tool)"
        out_detail ""
        out_detail "To enable these submodules, choose one option:"
        out_detail "Option 1: Run 'gh auth login' then re-run './install'"
        out_detail "Option 2: Set up SSH key and add to GitHub:"
        out_detail "https://docs.github.com/en/authentication/connecting-to-github-with-ssh"
        out_detail ""
        out_detail "Continuing without private submodules..."
    fi

    if [[ ${private_count} -eq 0 ]]; then
        section_end "${public_count} public, 0 private (no SSH auth)"
    else
        section_end "${public_count} public, ${private_count} private"
    fi

    # Check if aesthetics submodule exists and offer to run its installer
    if [[ -d "${DOTFILES_DIR}/aesthetics" ]] && [[ -f "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh" ]]; then
        section "Themes"

        local theme_summary="skipped"

        if [[ "${FORCE}" == "true" ]] || [[ "${UNATTENDED}" == "true" ]]; then
            # In force mode, auto-install with non-interactive flags
            # Read preferred variants from the first theme's preferences.md
            local aesthetics_args=()
            local first_theme_dir
            first_theme_dir=$(find "${DOTFILES_DIR}/aesthetics/themes" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -1)
            if [[ -n "${first_theme_dir}" ]]; then
                local theme_name
                theme_name=$(basename "${first_theme_dir}")
                aesthetics_args+=(--theme "${theme_name}")

                local prefs="${first_theme_dir}/preferences.md"
                if [[ -f "${prefs}" ]]; then
                    local pref_variant pref_toggle
                    pref_variant=$(grep '^\*\*Primary variant\*\*:' "${prefs}" 2>/dev/null | sed 's/.*: *//' || true)
                    pref_toggle=$(grep '^\*\*Toggle variant\*\*:' "${prefs}" 2>/dev/null | sed 's/.*: *//' || true)
                    [[ -n "${pref_variant}" ]] && aesthetics_args+=(--variant "${pref_variant}")
                    [[ -n "${pref_toggle}" ]] && aesthetics_args+=(--toggle "${pref_toggle}")
                fi
            fi

            if run_with_status "Installing themes" \
                bash "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh" "${aesthetics_args[@]}"; then
                theme_summary=$(summarize_theme_install "${RWS_OUTPUT}")
                out_verbose "${RWS_OUTPUT}"
            else
                fail "Aesthetics install failed"
                out_verbose "${RWS_OUTPUT}"
            fi
        else
            _clear_inline
            read -p "Would you like to install themes from aesthetics? (y/N) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                if bash "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh"; then
                    theme_summary="installed"
                else
                    fail "Aesthetics install failed"
                fi
            else
                out_verbose "Skipping aesthetics theme installation"
                out_info "You can run it later with: bash ${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh"
            fi
        fi

        section_end "${theme_summary}"
    fi
}

# Install dotfiles using stow
install_dotfiles() {
    local os="$1"

    # Build packages array
    local packages=("${CORE_PACKAGES[@]}")
    if [[ "${MINIMAL}" != "true" ]]; then
        packages+=("${OPTIONAL_PACKAGES[@]}")
    fi

    # Stow all packages
    section "Dotfiles"
    out_verbose "Packages to install: ${packages[*]}"
    local success_count=0
    local fail_count=0

    for package in "${packages[@]}"; do
        if stow_package "${package}"; then
            success_count=$((success_count + 1))
        else
            fail_count=$((fail_count + 1))
        fi
    done

    section_end "${success_count}/${#packages[@]} stowed"

    # Create additional symlinks
    create_additional_symlinks

    # Platform-specific setup
    case "${os}" in
        macos)
            setup_macos
            ;;
    esac

    if [[ -d "${BACKUP_DIR}" ]] && [[ -n "$(ls -A "${BACKUP_DIR}" 2>/dev/null)" ]]; then
        out_info "Backups saved to: ${BACKUP_DIR}"
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        out_warning "DRY RUN completed - no actual changes were made"
    fi
}

# Stow a single package
stow_package() {
    local package="$1"
    local package_dir="${DOTFILES_DIR}/${package}"

    if [[ ! -d "${package_dir}" ]]; then
        fail "${package}: package directory not found"
        return 1
    fi

    # Safety check: Ensure we're in the dotfiles directory
    if [[ "$(pwd)" != "${DOTFILES_DIR}" ]]; then
        fail "${package}: internal error (not in dotfiles directory)"
        return 1
    fi

    # Safety check: Ensure target is HOME
    if [[ "${STOW_TARGET}" != "${HOME}" ]]; then
        fail "${package}: internal error (STOW_TARGET must be HOME)"
        return 1
    fi

    out_verbose "Stowing ${package}..."

    # Backup any conflicts first (unless --force is used)
    if [[ "${FORCE}" != "true" ]]; then
        backup_conflicts "${package}"
    fi

    # Run stow with --restow to handle existing symlinks gracefully
    # --restow first unstows then restows, handling changes better
    # CRITICAL: Always run from DOTFILES_DIR with target set to HOME
    # This prevents stow from creating symlinks in the wrong location
    local stow_cmd="stow --restow --target=\"${STOW_TARGET}\" --ignore='^README.*' --ignore='Brewfile' --ignore='yabai\.sh' --ignore='KEYBINDINGS' --ignore='layouts\.json' --ignore='\.DS_Store' --dotfiles"
    if [[ "${VERBOSE}" == "true" ]]; then
        stow_cmd="${stow_cmd} --verbose=4"
    fi
    stow_cmd="${stow_cmd} \"${package}\""

    if [[ "${DRY_RUN}" == "true" ]]; then
        stow_cmd="stow --no --target=\"${STOW_TARGET}\" --ignore='^README.*' --ignore='Brewfile' --ignore='yabai\.sh' --ignore='KEYBINDINGS' --ignore='layouts\.json' --ignore='\.DS_Store' --dotfiles \"${package}\""
    fi

    out_verbose "Running: ${stow_cmd}"

    local stow_output
    if stow_output=$(eval "cd '${DOTFILES_DIR}' && ${stow_cmd}" 2>&1); then
        tick
        return 0
    else
        # Stow failed — if --force, remove conflicting targets and retry
        if [[ "${FORCE}" == "true" ]] && [[ "${DRY_RUN}" == "false" ]]; then
            out_verbose "Stow conflict for ${package}, removing conflicting targets..."
            remove_stow_conflicts "${package}"
            local retry_cmd="stow --stow --target=\"${STOW_TARGET}\" --ignore='^README.*' --ignore='Brewfile' --ignore='yabai\.sh' --ignore='KEYBINDINGS' --ignore='layouts\.json' --ignore='\.DS_Store' --dotfiles"
            if [[ "${VERBOSE}" == "true" ]]; then
                retry_cmd="${retry_cmd} --verbose=4"
            fi
            retry_cmd="${retry_cmd} \"${package}\""
            if eval "cd '${DOTFILES_DIR}' && ${retry_cmd}" 2>&1; then
                tick
                return 0
            fi
        fi
        fail "${package}: stow failed"
        if [[ -n "${stow_output}" ]]; then
            out_verbose "${stow_output}"
        fi
        return 1
    fi
}

# Create additional symlinks (bash_profile, etc.)
create_additional_symlinks() {
    out_verbose "Creating additional symlinks..."

    # Link .bash_profile -> .bashrc
    if [[ -f "${HOME}/.bashrc" ]]; then
        out_verbose "Linking .bash_profile -> .bashrc"
        if [[ "${DRY_RUN}" == "false" ]]; then
            rm -f "${HOME}/.bash_profile"
            ln -sf "${HOME}/.bashrc" "${HOME}/.bash_profile"
        fi
        out_success "Linked .bash_profile -> .bashrc"
    fi

    # Clean up broken symlinks from renamed/deleted packages
    # (e.g., youtube-dl → yt-dlp rename leaves stale .config/youtube-dl)
    local stale_paths=(
        "${HOME}/.config"/*
        "${HOME}/."*
    )

    for path in "${stale_paths[@]}"; do
        [[ ! -L "$path" ]] && continue
        [[ -e "$path" ]] && continue  # Only broken symlinks

        local target
        target=$(readlink "$path" 2>/dev/null || true)
        if [[ "$target" == *"/dotfiles/"* ]] || [[ "$target" == *"dotfiles/"* ]]; then
            if [[ "${DRY_RUN}" == "false" ]]; then
                rm -f "$path"
                out_success "Cleaned stale symlink: $(basename "$path")"
            else
                out_warning "Would remove stale symlink: $(basename "$path") -> $target"
            fi
        fi
    done
}

# Install dependencies for packages that need them
install_package_dependencies() {
    section "OpenCode"

    # opencode ecosystem: MCP servers, plugins, and supporting tools
    if [[ -f "${DOTFILES_DIR}/scripts/bootstrap-opencode.sh" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            out_info "Would run: scripts/bootstrap-opencode.sh"
            section_end "skipped (dry run)"
        else
            if run_with_status "Bootstrapping OpenCode ecosystem" \
                bash "${DOTFILES_DIR}/scripts/bootstrap-opencode.sh"; then
                out_verbose "${RWS_OUTPUT}"
                section_end "installed"
            else
                fail "OpenCode bootstrap had issues"
                out_verbose "${RWS_OUTPUT}"
                section_end "issues"
            fi
        fi
    else
        section_end "skipped"
    fi
}

# macOS specific setup
setup_macos() {
    out_verbose "Setting up macOS-specific configurations..."

    if [[ -f "${DOTFILES_DIR}/scripts/install-mac.sh" ]]; then
        out_warning "macOS system preferences can be configured"
        out_detail "Run: bash ${DOTFILES_DIR}/scripts/install-mac.sh"
        out_detail "This will modify system defaults and requires manual execution"
    fi
}

# -----------------------------------------------------------------------------
# Main Installation Logic
# -----------------------------------------------------------------------------

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                ;;
            --dry-run)
                DRY_RUN=true
                out_warning "DRY RUN MODE - No changes will be made"
                shift
                ;;
            --no-packages)
                INSTALL_PACKAGES=false
                shift
                ;;
            --minimal)
                MINIMAL=true
                shift
                ;;
            --full)
                FULL_INSTALL=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --force|-f)
                FORCE=true
                out_warning "FORCE MODE - Existing files will be overwritten without backup"
                shift
                ;;
            --unattended)
                UNATTENDED=true
                FORCE=true
                RELINK=true
                shift
                ;;
            --relink|-r)
                RELINK=true
                out_success "RELINK MODE - Will update symlinks from old dotfiles locations"
                shift
                ;;
            *)
                out_error "Unknown option: $1"
                show_help
                ;;
        esac
    done

    # Banner
    banner "dotfiles"

    # Detect OS
    local os
    os=$(detect_os)
    out_info "Detected OS: ${os}"

    write_dotfiles_env

    # Check for stow
    if ! command_exists stow; then
        out_error "GNU Stow is not installed!"
        echo "Install it first:"
        case "${os}" in
            macos)
                echo "  brew install stow"
                ;;
            debian)
                echo "  sudo apt install stow"
                ;;
            *)
                echo "  See: https://www.gnu.org/software/stow/"
                ;;
        esac
        exit 1
    fi
    out_success "GNU Stow is installed"

    # Install packages from package managers
    install_packages "${os}"

    # Bootstrap oh-my-zsh if not already installed
    bootstrap_oh_my_zsh

    # Initialize git submodules (including aesthetics)
    init_submodules

    # Install dotfiles
    install_dotfiles "${os}"

    # Install dependencies for packages that need post-stow setup
    install_package_dependencies

    # Validate stow configuration
    if [[ "${DRY_RUN}" != "true" ]] && [[ -x "${DOTFILES_DIR}/scripts/validate-stow.sh" ]]; then
        section "Validation"
        if run_with_status "Validating stow symlinks" \
            bash "${DOTFILES_DIR}/scripts/validate-stow.sh"; then
            out_verbose "${RWS_OUTPUT}"
            local validation_summary
            validation_summary=$(printf "%s\n" "${RWS_OUTPUT}" | tail -1)
            section_end "${validation_summary}"
        else
            out_verbose "${RWS_OUTPUT}"
            section_end "issues"
            fail "stow validation"
        fi
    fi

    if [[ "${DRY_RUN}" != "true" ]]; then
        local next_steps=()
        next_steps+=("Restart your shell or run: source ~/.zshrc (or ~/.bashrc)")
        if [[ -d "${BACKUP_DIR}" ]] && [[ -n "$(ls -A "${BACKUP_DIR}" 2>/dev/null)" ]]; then
            next_steps+=("Review the backup directory if needed: ${BACKUP_DIR}")
        fi
        if [[ "${os}" == "macos" ]]; then
            next_steps+=("Optionally run macOS setup: bash ${DOTFILES_DIR}/scripts/install-mac.sh")
        fi

        if [[ ${#next_steps[@]} -gt 0 ]]; then
            echo ""
            out_info "Next steps:"
            local step_num=1
            for step in "${next_steps[@]}"; do
                out_detail "${step_num}. ${step}"
                ((step_num++))
            done
        fi
    fi

    final_summary
}

# Run main function
main "$@"
