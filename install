#!/usr/bin/env bash
#
# Dotfiles Installation Script
# A modern, maintainable installer for dotfiles using GNU Stow
#
# Usage: ./install [OPTIONS]
#   --help          Show this help message
#   --dry-run       Show what would be done without making changes
#   --no-packages   Skip package installation
#   --minimal       Install only core packages
#   --verbose       Show detailed output
#   --force         Skip backups and overwrite existing files

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STOW_TARGET="${HOME}"
BACKUP_DIR="${HOME}/.dotfiles-backup-$(date +%Y%m%d-%H%M%S)"

# Core packages that should be installed on all systems (alphabetically sorted)
CORE_PACKAGES=(
    bash
    git
    vim
    zsh
)

# Optional packages - can be skipped with --minimal (alphabetically sorted)
OPTIONAL_PACKAGES=(
    aerospace
    doom
    emacs
    gnupg
    kitty
    mail
    secrets
    sketchybar
    skhd
    ssh
    x-windows
    yabai
    youtube-dl
)

# Flags
DRY_RUN=false
INSTALL_PACKAGES=true
MINIMAL=false
VERBOSE=false
FORCE=false
RELINK=false  # Automatically relink symlinks from old dotfiles locations

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

print_header() {
    echo -e "\n${BLUE}==>${NC} ${1}"
}

print_success() {
    echo -e "${GREEN}✓${NC} ${1}"
}

print_warning() {
    echo -e "${YELLOW}!${NC} ${1}"
}

print_error() {
    echo -e "${RED}✗${NC} ${1}" >&2
}

print_verbose() {
    if [[ "${VERBOSE}" == "true" ]]; then
        echo -e "  ${1}"
    fi
}

show_help() {
    cat << EOF
Dotfiles Installation Script

Usage: ./install [OPTIONS]

OPTIONS:
    --help          Show this help message
    --dry-run       Show what would be done without making changes
    --no-packages   Skip package manager installations
    --minimal       Install only core packages (bash, git, vim, zsh)
    --verbose       Show detailed output
    --force         Skip backups and overwrite existing files (use with caution!)
    --relink        Automatically relink symlinks from old dotfiles locations

HANDLING EXISTING FILES:
    By default, existing files are backed up to ~/.dotfiles-backup-TIMESTAMP/
    Existing symlinks to these dotfiles are detected and left alone.
    Broken symlinks are automatically removed.

    If you have symlinks from a previous dotfiles location (e.g., Dropbox/Code/dotfiles),
    use --relink to automatically update them to the new location.

    Use --dry-run to see what will happen before making changes.

EXAMPLES:
    ./install                    # Full installation with backups
    ./install --minimal          # Install core configs only
    ./install --dry-run          # Preview changes without applying
    ./install --relink           # Update symlinks from old dotfiles location
    ./install --relink --dry-run # Preview relinking without changes
    ./install --force            # Overwrite existing files without backup

EOF
    exit 0
}

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if [[ -f /etc/debian_version ]]; then
            echo "debian"
        elif [[ -f /etc/redhat-release ]]; then
            echo "redhat"
        else
            echo "linux"
        fi
    else
        echo "unknown"
    fi
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Install package manager packages
install_packages() {
    local os="$1"

    if [[ "${INSTALL_PACKAGES}" != "true" ]]; then
        print_warning "Skipping package installation (--no-packages)"
        return 0
    fi

    print_header "Installing packages for ${os}..."

    case "${os}" in
        macos)
            if ! command_exists brew; then
                print_error "Homebrew not found. Install from https://brew.sh"
                return 1
            fi

            if [[ -f "${DOTFILES_DIR}/homebrew/Brewfile" ]]; then
                print_verbose "Running: brew bundle --file=${DOTFILES_DIR}/homebrew/Brewfile"
                if [[ "${DRY_RUN}" == "false" ]]; then
                    brew bundle --file="${DOTFILES_DIR}/homebrew/Brewfile" || {
                        print_warning "Some Homebrew packages failed to install"
                    }
                fi
                print_success "Homebrew packages processed"
            else
                print_warning "Brewfile not found at ${DOTFILES_DIR}/homebrew/Brewfile"
            fi
            ;;

        debian)
            if [[ -f "${DOTFILES_DIR}/scripts/install-debian-packages.sh" ]]; then
                print_verbose "Running: ${DOTFILES_DIR}/scripts/install-debian-packages.sh"
                if [[ "${DRY_RUN}" == "false" ]]; then
                    bash "${DOTFILES_DIR}/scripts/install-debian-packages.sh" || {
                        print_warning "Some Debian packages failed to install"
                    }
                fi
                print_success "Debian packages processed"
            else
                print_warning "Debian package script not found"
            fi
            ;;

        *)
            print_warning "Unknown OS, skipping package installation"
            ;;
    esac
}

# Check if a symlink points to a dotfiles directory (any location)
is_dotfiles_symlink() {
    local target="$1"
    # Common patterns for dotfiles directories
    [[ "$target" == *"/dotfiles/"* ]] || \
    [[ "$target" == *"/.dotfiles/"* ]] || \
    [[ "$target" == *"/.dots/"* ]] || \
    [[ "$target" == *"/Dropbox/Code/dotfiles/"* ]] || \
    [[ "$target" == *"/iCloud/"*"/dotfiles/"* ]]
}

# Backup existing files that would conflict with stow
backup_conflicts() {
    local package="$1"
    local package_dir="${DOTFILES_DIR}/${package}"

    if [[ ! -d "${package_dir}" ]]; then
        return 0
    fi

    # Find files that would be created by stow
    while IFS= read -r -d '' file; do
        local rel_path="${file#$package_dir/}"
        # Handle stow's --dotfiles convention: dot-foo -> .foo
        local stowed_path="${rel_path//dot-/.}"
        local target_file="${STOW_TARGET}/${stowed_path}"

        # Skip if target doesn't exist
        [[∑ ! -e "${target_file}" ]] && [[ ! -L "${target_file}" ]] && continue

        # If target is a symlink
        if [[ -L "${target_file}" ]]; then
            local link_target=$(readlink "${target_file}")

            # Check if it points to our current dotfiles directory
            # Resolve relative symlinks to check if they point to current dotfiles
            local resolved_target
            if [[ "${link_target}" = /* ]]; then
                # Absolute path
                resolved_target="${link_target}"
            else
                # Relative path - resolve from $HOME
                resolved_target="$(cd "${HOME}" && cd "$(dirname "${link_target}")" 2>/dev/null && pwd)/$(basename "${link_target}")" || resolved_target=""
            fi

            if [[ "${link_target}" == *"${DOTFILES_DIR}"* ]] || [[ "${resolved_target}" == "${DOTFILES_DIR}"* ]]; then
                print_verbose "Symlink already managed: ${target_file}"
                continue
            fi

            # Check if it's a broken/stale symlink
            if [[ ! -e "${target_file}" ]]; then
                print_warning "Removing broken symlink: ${target_file} -> ${link_target}"
                if [[ "${DRY_RUN}" == "false" ]]; then
                    rm "${target_file}"
                fi
                continue
            fi

            # Check if it points to another dotfiles directory (NOT the current one)
            if is_dotfiles_symlink "${link_target}" && \
               [[ "${link_target}" != *"${DOTFILES_DIR}"* ]] && \
               [[ "${resolved_target}" != "${DOTFILES_DIR}"* ]]; then
                # Only relink if it's pointing to a DIFFERENT dotfiles directory
                if [[ "${RELINK}" == "true" ]]; then
                    print_verbose "Relinking from old dotfiles: ${target_file}"
                    print_verbose "  Old: ${link_target}"
                    print_verbose "  New: ${DOTFILES_DIR}/${package}/${rel_path}"
                    if [[ "${DRY_RUN}" == "false" ]]; then
                        rm "${target_file}"
                    fi
                else
                    print_warning "Dotfiles symlink from different location: ${target_file}"
                    print_warning "  Points to: ${link_target}"
                    print_warning "  Use --relink to automatically update these symlinks"
                fi
                continue
            fi

            # Symlink to somewhere else (not dotfiles)
            print_warning "External symlink found: ${target_file} -> ${link_target}"
            if [[ "${DRY_RUN}" == "false" ]] && [[ "${FORCE}" == "true" ]]; then
                mkdir -p "$(dirname "${BACKUP_DIR}/${stowed_path}")"
                mv "${target_file}" "${BACKUP_DIR}/${stowed_path}"
                echo "${link_target}" > "${BACKUP_DIR}/${stowed_path}.symlink-target"
            fi
        # Regular file exists
        elif [[ -e "${target_file}" ]]; then
            print_verbose "Backing up: ${target_file}"
            if [[ "${DRY_RUN}" == "false" ]]; then
                mkdir -p "$(dirname "${BACKUP_DIR}/${stowed_path}")"
                mv "${target_file}" "${BACKUP_DIR}/${stowed_path}"
            fi
        fi
    done < <(find "${package_dir}" -type f -print0)
}

# Initialize git submodules
init_submodules() {
    print_header "Initializing git submodules..."

    # Check if .gitmodules exists
    if [[ ! -f "${DOTFILES_DIR}/.gitmodules" ]]; then
        print_verbose "No submodules found"
        return 0
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        print_verbose "Would initialize submodules"
        return 0
    fi

    # Initialize and update all submodules
    if git -C "${DOTFILES_DIR}" submodule init && \
       git -C "${DOTFILES_DIR}" submodule update --init --recursive; then
        print_success "Submodules initialized"
    else
        print_warning "Failed to initialize some submodules (may need manual setup)"
    fi

    # Check if aesthetics submodule exists and offer to run its installer
    if [[ -d "${DOTFILES_DIR}/aesthetics" ]] && [[ -f "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh" ]]; then
        echo ""
        print_header "Aesthetics Theme Manager Detected"
        echo "The aesthetics submodule provides theme management for your terminal and apps."
        echo ""

        if [[ "${FORCE}" == "true" ]]; then
            # In force mode, auto-install
            print_success "Auto-installing aesthetics themes..."
            bash "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh" || print_warning "Aesthetics install failed"
        else
            # Ask user
            read -p "Would you like to install themes from aesthetics? (y/N) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                bash "${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh"
            else
                print_verbose "Skipping aesthetics theme installation"
                echo "You can run it later with: bash ${DOTFILES_DIR}/aesthetics/scripts/install-theme.sh"
            fi
        fi
    fi
}

# Install dotfiles using stow
install_dotfiles() {
    local os="$1"

    # Build packages array
    local packages=("${CORE_PACKAGES[@]}")
    if [[ "${MINIMAL}" != "true" ]]; then
        packages+=("${OPTIONAL_PACKAGES[@]}")
    fi

    # Stow all packages
    print_header "Installing dotfiles..."
    print_verbose "Packages to install: ${packages[*]}"
    local success_count=0
    local fail_count=0

    for package in "${packages[@]}"; do
        if stow_package "${package}"; then
            success_count=$((success_count + 1))
        else
            fail_count=$((fail_count + 1))
        fi
    done

    # Create additional symlinks
    create_additional_symlinks

    # Platform-specific setup
    case "${os}" in
        macos)
            setup_macos
            ;;
    esac

    # Summary
    echo ""
    print_header "Installation Summary"
    echo "  Successfully installed: ${success_count} packages"
    if [[ ${fail_count} -gt 0 ]]; then
        echo "  Failed: ${fail_count} packages"
    fi

    if [[ -d "${BACKUP_DIR}" ]] && [[ -n "$(ls -A "${BACKUP_DIR}" 2>/dev/null)" ]]; then
        echo "  Backups saved to: ${BACKUP_DIR}"
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        echo ""
        print_warning "DRY RUN completed - no actual changes were made"
    fi
}

# Stow a single package
stow_package() {
    local package="$1"
    local package_dir="${DOTFILES_DIR}/${package}"

    if [[ ! -d "${package_dir}" ]]; then
        print_warning "Package directory not found: ${package}"
        return 1
    fi

    # Safety check: Ensure we're in the dotfiles directory
    if [[ "$(pwd)" != "${DOTFILES_DIR}" ]]; then
        print_error "Internal error: not in dotfiles directory"
        return 1
    fi

    # Safety check: Ensure target is HOME
    if [[ "${STOW_TARGET}" != "${HOME}" ]]; then
        print_error "Internal error: STOW_TARGET must be HOME directory"
        return 1
    fi

    print_verbose "Stowing ${package}..."

    # Backup any conflicts first (unless --force is used)
    if [[ "${FORCE}" != "true" ]]; then
        backup_conflicts "${package}"
    fi

    # Run stow with --restow to handle existing symlinks gracefully
    # --restow first unstows then restows, handling changes better
    # CRITICAL: Always run from DOTFILES_DIR with target set to HOME
    # This prevents stow from creating symlinks in the wrong location
    local stow_cmd="stow --restow --target=\"${STOW_TARGET}\" --ignore='^README.*' --dotfiles"
    if [[ "${VERBOSE}" == "true" ]]; then
        stow_cmd="${stow_cmd} --verbose=4"
    fi
    stow_cmd="${stow_cmd} \"${package}\""

    if [[ "${DRY_RUN}" == "true" ]]; then
        stow_cmd="stow --no --target=\"${STOW_TARGET}\" --ignore='^README.*' --dotfiles \"${package}\""
    fi

    print_verbose "Running: ${stow_cmd}"

    if eval "cd '${DOTFILES_DIR}' && ${stow_cmd}"; then
        print_success "Stowed ${package}"
        return 0
    else
        print_error "Failed to stow ${package}"
        print_warning "Try running with --dry-run first to see what would happen"
        print_warning "Or manually remove conflicting files/symlinks in your home directory"
        return 1
    fi
}

# Create additional symlinks (bash_profile, etc.)
create_additional_symlinks() {
    print_header "Creating additional symlinks..."

    # Link .bash_profile -> .bashrc
    if [[ -f "${HOME}/.bashrc" ]]; then
        print_verbose "Linking .bash_profile -> .bashrc"
        if [[ "${DRY_RUN}" == "false" ]]; then
            rm -f "${HOME}/.bash_profile"
            ln -sf "${HOME}/.bashrc" "${HOME}/.bash_profile"
        fi
        print_success "Linked .bash_profile -> .bashrc"
    fi
}

# macOS specific setup
setup_macos() {
    print_header "Setting up macOS-specific configurations..."

    if [[ -f "${DOTFILES_DIR}/scripts/install-mac.sh" ]]; then
        print_warning "macOS system preferences can be configured"
        echo "Run: bash ${DOTFILES_DIR}/scripts/install-mac.sh"
        echo "This will modify system defaults and requires manual execution"
    fi
}

# -----------------------------------------------------------------------------
# Main Installation Logic
# -----------------------------------------------------------------------------

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                ;;
            --dry-run)
                DRY_RUN=true
                print_warning "DRY RUN MODE - No changes will be made"
                shift
                ;;
            --no-packages)
                INSTALL_PACKAGES=false
                shift
                ;;
            --minimal)
                MINIMAL=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --force|-f)
                FORCE=true
                print_warning "FORCE MODE - Existing files will be overwritten without backup"
                shift
                ;;
            --relink|-r)
                RELINK=true
                print_success "RELINK MODE - Will update symlinks from old dotfiles locations"
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                show_help
                ;;
        esac
    done

    # Banner
    cat << "EOF"
╔═══════════════════════════════════════╗
║     Dotfiles Installation Script      ║
╚═══════════════════════════════════════╝
EOF

    # Detect OS
    local os
    os=$(detect_os)
    print_header "Detected OS: ${os}"

    # Check for stow
    if ! command_exists stow; then
        print_error "GNU Stow is not installed!"
        echo "Install it first:"
        case "${os}" in
            macos)
                echo "  brew install stow"
                ;;
            debian)
                echo "  sudo apt install stow"
                ;;
            *)
                echo "  See: https://www.gnu.org/software/stow/"
                ;;
        esac
        exit 1
    fi
    print_success "GNU Stow is installed"

    # Install packages from package managers
    install_packages "${os}"

    # Initialize git submodules (including aesthetics)
    init_submodules

    # Install dotfiles
    install_dotfiles "${os}"

    # Validate stow configuration
    if [[ "${DRY_RUN}" != "true" ]] && [[ -x "${DOTFILES_DIR}/scripts/validate-stow.sh" ]]; then
        echo ""
        print_info "Validating stow configuration..."
        if bash "${DOTFILES_DIR}/scripts/validate-stow.sh"; then
            print_success "Stow validation passed"
        else
            print_warning "Stow validation found issues (see above)"
        fi
    fi

    # Final message
    if [[ "${DRY_RUN}" != "true" ]]; then
        echo ""
        print_success "Installation complete!"
        echo ""
        echo "Next steps:"
        echo "  1. Restart your shell or run: source ~/.zshrc (or ~/.bashrc)"
        if [[ -d "${BACKUP_DIR}" ]] && [[ -n "$(ls -A "${BACKUP_DIR}" 2>/dev/null)" ]]; then
            echo "  2. Review the backup directory if needed: ${BACKUP_DIR}"
        fi
        if [[ "${os}" == "macos" ]]; then
            echo "  3. Optionally run macOS setup: bash ${DOTFILES_DIR}/scripts/install-mac.sh"
        fi
    fi
}

# Run main function
main "$@"
